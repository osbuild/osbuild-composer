// Package v2 provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.4.1 DO NOT EDIT.
package v2

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"github.com/oapi-codegen/runtime"
	openapi_types "github.com/oapi-codegen/runtime/types"
)

const (
	BearerScopes = "Bearer.Scopes"
)

// Defines values for AzureUploadOptionsHyperVGeneration.
const (
	V1 AzureUploadOptionsHyperVGeneration = "V1"
	V2 AzureUploadOptionsHyperVGeneration = "V2"
)

// Defines values for BlueprintCustomizationsPartitioningMode.
const (
	BlueprintCustomizationsPartitioningModeAutoLvm BlueprintCustomizationsPartitioningMode = "auto-lvm"
	BlueprintCustomizationsPartitioningModeLvm     BlueprintCustomizationsPartitioningMode = "lvm"
	BlueprintCustomizationsPartitioningModeRaw     BlueprintCustomizationsPartitioningMode = "raw"
)

// Defines values for BtrfsVolumeType.
const (
	Btrfs BtrfsVolumeType = "btrfs"
)

// Defines values for ComposeStatusValue.
const (
	ComposeStatusValueFailure ComposeStatusValue = "failure"
	ComposeStatusValuePending ComposeStatusValue = "pending"
	ComposeStatusValueSuccess ComposeStatusValue = "success"
)

// Defines values for CustomizationsPartitioningMode.
const (
	CustomizationsPartitioningModeAutoLvm CustomizationsPartitioningMode = "auto-lvm"
	CustomizationsPartitioningModeLvm     CustomizationsPartitioningMode = "lvm"
	CustomizationsPartitioningModeRaw     CustomizationsPartitioningMode = "raw"
)

// Defines values for DiskType.
const (
	Dos DiskType = "dos"
	Gpt DiskType = "gpt"
)

// Defines values for FilesystemTypedFsType.
const (
	FilesystemTypedFsTypeExt4 FilesystemTypedFsType = "ext4"
	FilesystemTypedFsTypeVfat FilesystemTypedFsType = "vfat"
	FilesystemTypedFsTypeXfs  FilesystemTypedFsType = "xfs"
)

// Defines values for FilesystemTypedType.
const (
	Plain FilesystemTypedType = "plain"
)

// Defines values for ImageSBOMPipelinePurpose.
const (
	Buildroot ImageSBOMPipelinePurpose = "buildroot"
	Image     ImageSBOMPipelinePurpose = "image"
)

// Defines values for ImageSBOMSbomType.
const (
	Spdx ImageSBOMSbomType = "spdx"
)

// Defines values for ImageStatusValue.
const (
	ImageStatusValueBuilding    ImageStatusValue = "building"
	ImageStatusValueFailure     ImageStatusValue = "failure"
	ImageStatusValuePending     ImageStatusValue = "pending"
	ImageStatusValueRegistering ImageStatusValue = "registering"
	ImageStatusValueSuccess     ImageStatusValue = "success"
	ImageStatusValueUploading   ImageStatusValue = "uploading"
)

// Defines values for ImageTypes.
const (
	ImageTypesAws                    ImageTypes = "aws"
	ImageTypesAwsHaRhui              ImageTypes = "aws-ha-rhui"
	ImageTypesAwsRhui                ImageTypes = "aws-rhui"
	ImageTypesAwsSapRhui             ImageTypes = "aws-sap-rhui"
	ImageTypesAzure                  ImageTypes = "azure"
	ImageTypesAzureEap7Rhui          ImageTypes = "azure-eap7-rhui"
	ImageTypesAzureRhui              ImageTypes = "azure-rhui"
	ImageTypesAzureSapRhui           ImageTypes = "azure-sap-rhui"
	ImageTypesEdgeCommit             ImageTypes = "edge-commit"
	ImageTypesEdgeContainer          ImageTypes = "edge-container"
	ImageTypesEdgeInstaller          ImageTypes = "edge-installer"
	ImageTypesGcp                    ImageTypes = "gcp"
	ImageTypesGcpRhui                ImageTypes = "gcp-rhui"
	ImageTypesGuestImage             ImageTypes = "guest-image"
	ImageTypesImageInstaller         ImageTypes = "image-installer"
	ImageTypesIotBootableContainer   ImageTypes = "iot-bootable-container"
	ImageTypesIotCommit              ImageTypes = "iot-commit"
	ImageTypesIotContainer           ImageTypes = "iot-container"
	ImageTypesIotInstaller           ImageTypes = "iot-installer"
	ImageTypesIotRawImage            ImageTypes = "iot-raw-image"
	ImageTypesIotSimplifiedInstaller ImageTypes = "iot-simplified-installer"
	ImageTypesLiveInstaller          ImageTypes = "live-installer"
	ImageTypesMinimalRaw             ImageTypes = "minimal-raw"
	ImageTypesOci                    ImageTypes = "oci"
	ImageTypesVsphere                ImageTypes = "vsphere"
	ImageTypesVsphereOva             ImageTypes = "vsphere-ova"
	ImageTypesWsl                    ImageTypes = "wsl"
)

// Defines values for LogicalVolumeFsType.
const (
	LogicalVolumeFsTypeExt4 LogicalVolumeFsType = "ext4"
	LogicalVolumeFsTypeVfat LogicalVolumeFsType = "vfat"
	LogicalVolumeFsTypeXfs  LogicalVolumeFsType = "xfs"
)

// Defines values for UploadStatusValue.
const (
	Failure UploadStatusValue = "failure"
	Pending UploadStatusValue = "pending"
	Running UploadStatusValue = "running"
	Success UploadStatusValue = "success"
)

// Defines values for UploadTypes.
const (
	UploadTypesAws              UploadTypes = "aws"
	UploadTypesAwsS3            UploadTypes = "aws.s3"
	UploadTypesAzure            UploadTypes = "azure"
	UploadTypesContainer        UploadTypes = "container"
	UploadTypesGcp              UploadTypes = "gcp"
	UploadTypesLocal            UploadTypes = "local"
	UploadTypesOciObjectstorage UploadTypes = "oci.objectstorage"
	UploadTypesPulpOstree       UploadTypes = "pulp.ostree"
)

// Defines values for VolumeGroupType.
const (
	Lvm VolumeGroupType = "lvm"
)

// AWSEC2CloneCompose defines model for AWSEC2CloneCompose.
type AWSEC2CloneCompose struct {
	Region            string    `json:"region"`
	ShareWithAccounts *[]string `json:"share_with_accounts,omitempty"`
}

// AWSEC2UploadOptions defines model for AWSEC2UploadOptions.
type AWSEC2UploadOptions struct {
	Region            string   `json:"region"`
	ShareWithAccounts []string `json:"share_with_accounts"`
	SnapshotName      *string  `json:"snapshot_name,omitempty"`
}

// AWSEC2UploadStatus defines model for AWSEC2UploadStatus.
type AWSEC2UploadStatus struct {
	Ami    string `json:"ami"`
	Region string `json:"region"`
}

// AWSS3UploadOptions defines model for AWSS3UploadOptions.
type AWSS3UploadOptions struct {
	// Public If set to false (the default value), a long, obfuscated URL
	// is returned. Its expiration might be sooner than for other upload
	// targets.
	//
	// If set to true, a shorter URL is returned and
	// its expiration is the same as for the other upload targets.
	Public *bool  `json:"public,omitempty"`
	Region string `json:"region"`
}

// AWSS3UploadStatus defines model for AWSS3UploadStatus.
type AWSS3UploadStatus struct {
	Url string `json:"url"`
}

// AzureUploadOptions defines model for AzureUploadOptions.
type AzureUploadOptions struct {
	// HyperVGeneration Choose the VM Image HyperV generation, different features on Azure are available
	// depending on the HyperV generation.
	HyperVGeneration *AzureUploadOptionsHyperVGeneration `json:"hyper_v_generation,omitempty"`

	// ImageName Name of the uploaded image. It must be unique in the given resource group.
	// If name is omitted from the request, a random one based on a UUID is
	// generated.
	ImageName *string `json:"image_name,omitempty"`

	// Location Location of the provided resource_group, where the image should be uploaded and registered.
	// How to list all locations:
	// https://docs.microsoft.com/en-us/cli/azure/account?view=azure-cli-latest#az_account_list_locations'
	// If the location is not specified, it is deducted from the provided resource_group.
	Location *string `json:"location,omitempty"`

	// ResourceGroup Name of the resource group where the image should be uploaded.
	ResourceGroup string `json:"resource_group"`

	// SubscriptionId ID of subscription where the image should be uploaded.
	SubscriptionId string `json:"subscription_id"`

	// TenantId ID of the tenant where the image should be uploaded.
	// How to find it in the Azure Portal:
	// https://docs.microsoft.com/en-us/azure/active-directory/fundamentals/active-directory-how-to-find-tenant
	TenantId string `json:"tenant_id"`
}

// AzureUploadOptionsHyperVGeneration Choose the VM Image HyperV generation, different features on Azure are available
// depending on the HyperV generation.
type AzureUploadOptionsHyperVGeneration string

// AzureUploadStatus defines model for AzureUploadStatus.
type AzureUploadStatus struct {
	ImageName string `json:"image_name"`
}

// Blueprint defines model for Blueprint.
type Blueprint struct {
	// Containers Container images to embed into the final artfact
	Containers     *[]Container             `json:"containers,omitempty"`
	Customizations *BlueprintCustomizations `json:"customizations,omitempty"`
	Description    *string                  `json:"description,omitempty"`

	// Distro The distribution to use for the compose. If left empty the host
	// distro will be used.
	Distro         *string   `json:"distro,omitempty"`
	EnabledModules *[]Module `json:"enabled_modules,omitempty"`

	// Groups Package groups to be installed
	Groups *[]PackageGroup `json:"groups,omitempty"`

	// Modules An alias for packages, retained for backwards compatability
	Modules *[]Package `json:"modules,omitempty"`
	Name    string     `json:"name"`

	// Packages Packages to be installed
	Packages *[]Package `json:"packages,omitempty"`

	// Version A semver version number
	Version *string `json:"version,omitempty"`
}

// BlueprintCustomizations defines model for BlueprintCustomizations.
type BlueprintCustomizations struct {
	Cacerts *CACertsCustomization `json:"cacerts,omitempty"`

	// Directories Directories to create in the final artifact
	Directories *[]Directory `json:"directories,omitempty"`
	Disk        *Disk        `json:"disk,omitempty"`

	// Fdo FIDO device onboard configuration
	Fdo *FDO `json:"fdo,omitempty"`

	// Files Files to create in the final artifact
	Files *[]BlueprintFile `json:"files,omitempty"`

	// Filesystem List of filesystem mountpoints to create
	Filesystem *[]BlueprintFilesystem `json:"filesystem,omitempty"`

	// Fips Enable FIPS mode
	Fips *bool `json:"fips,omitempty"`

	// Firewall Firewalld configuration
	Firewall *BlueprintFirewall `json:"firewall,omitempty"`

	// Group List of groups to create
	Group *[]Group `json:"group,omitempty"`

	// Hostname Configures the hostname
	Hostname *string `json:"hostname,omitempty"`

	// Ignition Ignition configuration
	Ignition *Ignition `json:"ignition,omitempty"`

	// InstallationDevice Name of the installation device, currently only useful for the edge-simplified-installer type
	InstallationDevice *string    `json:"installation_device,omitempty"`
	Installer          *Installer `json:"installer,omitempty"`
	Kernel             *Kernel    `json:"kernel,omitempty"`

	// Locale Locale configuration
	Locale   *Locale            `json:"locale,omitempty"`
	Openscap *BlueprintOpenSCAP `json:"openscap,omitempty"`

	// PartitioningMode Select how the disk image will be partitioned. 'auto-lvm' will use raw unless
	// there are one or more mountpoints in which case it will use LVM. 'lvm' always
	// uses LVM, even when there are no extra mountpoints. 'raw' uses raw partitions
	// even when there are one or more mountpoints.
	PartitioningMode *BlueprintCustomizationsPartitioningMode `json:"partitioning_mode,omitempty"`

	// Repositories Repositories to write to /etc/yum.repos.d/ in the final image. Note
	// that these are not used at build time.
	Repositories *[]BlueprintRepository `json:"repositories,omitempty"`
	Rhsm         *RHSMCustomization     `json:"rhsm,omitempty"`
	Rpm          *RPMCustomization      `json:"rpm,omitempty"`
	Services     *Services              `json:"services,omitempty"`

	// Sshkey List of ssh keys
	Sshkey *[]SSHKey `json:"sshkey,omitempty"`

	// Timezone Timezone configuration
	Timezone *Timezone `json:"timezone,omitempty"`

	// User List of users to create
	User *[]BlueprintUser `json:"user,omitempty"`
}

// BlueprintCustomizationsPartitioningMode Select how the disk image will be partitioned. 'auto-lvm' will use raw unless
// there are one or more mountpoints in which case it will use LVM. 'lvm' always
// uses LVM, even when there are no extra mountpoints. 'raw' uses raw partitions
// even when there are one or more mountpoints.
type BlueprintCustomizationsPartitioningMode string

// BlueprintFile A custom file to create in the final artifact.
type BlueprintFile struct {
	// Data Contents of the file as plain text
	Data *string `json:"data,omitempty"`

	// Group Group of the file as a gid or a group name
	Group *BlueprintFile_Group `json:"group,omitempty"`

	// Mode Permissions string for the file in octal format
	Mode *string `json:"mode,omitempty"`

	// Path Path to the file
	Path string `json:"path"`

	// User Owner of the file as a uid or a user name
	User *BlueprintFile_User `json:"user,omitempty"`
}

// BlueprintFileGroup0 defines model for .
type BlueprintFileGroup0 = string

// BlueprintFileGroup1 defines model for .
type BlueprintFileGroup1 = int64

// BlueprintFile_Group Group of the file as a gid or a group name
type BlueprintFile_Group struct {
	union json.RawMessage
}

// BlueprintFileUser0 defines model for .
type BlueprintFileUser0 = string

// BlueprintFileUser1 defines model for .
type BlueprintFileUser1 = int64

// BlueprintFile_User Owner of the file as a uid or a user name
type BlueprintFile_User struct {
	union json.RawMessage
}

// BlueprintFilesystem defines model for BlueprintFilesystem.
type BlueprintFilesystem struct {
	// Minsize size of the filesystem in bytes
	Minsize    uint64 `json:"minsize"`
	Mountpoint string `json:"mountpoint"`
}

// BlueprintFirewall Firewalld configuration
type BlueprintFirewall struct {
	// Ports List of ports (or port ranges) and protocols to open
	Ports *[]string `json:"ports,omitempty"`

	// Services Firewalld services to enable or disable
	Services *FirewallServices `json:"services,omitempty"`
	Zones    *[]FirewallZones  `json:"zones,omitempty"`
}

// BlueprintOpenSCAP defines model for BlueprintOpenSCAP.
type BlueprintOpenSCAP struct {
	Datastream    *string                `json:"datastream,omitempty"`
	JsonTailoring *OpenSCAPJSONTailoring `json:"json_tailoring,omitempty"`

	// PolicyId Puts a specified policy ID in the RHSM facts, so that any instances registered to
	// insights will be automatically connected to the compliance policy in the console.
	PolicyId  *openapi_types.UUID `json:"policy_id,omitempty"`
	ProfileId string              `json:"profile_id"`
	Tailoring *OpenSCAPTailoring  `json:"tailoring,omitempty"`
}

// BlueprintRepository defines model for BlueprintRepository.
type BlueprintRepository struct {
	Baseurls   *[]string `json:"baseurls,omitempty"`
	Enabled    *bool     `json:"enabled,omitempty"`
	Filename   *string   `json:"filename,omitempty"`
	Gpgcheck   *bool     `json:"gpgcheck,omitempty"`
	Gpgkeys    *[]string `json:"gpgkeys,omitempty"`
	Id         string    `json:"id"`
	Metalink   *string   `json:"metalink,omitempty"`
	Mirrorlist *string   `json:"mirrorlist,omitempty"`

	// ModuleHotfixes Disables modularity filtering for this repository.
	ModuleHotfixes *bool   `json:"module_hotfixes,omitempty"`
	Name           *string `json:"name,omitempty"`
	Priority       *int    `json:"priority,omitempty"`
	RepoGpgcheck   *bool   `json:"repo_gpgcheck,omitempty"`
	Sslverify      *bool   `json:"sslverify,omitempty"`
}

// BlueprintUser defines model for BlueprintUser.
type BlueprintUser struct {
	Description *string `json:"description,omitempty"`

	// Gid Group id to use instead of the default
	Gid *int `json:"gid,omitempty"`

	// Groups A list of additional groups to add the user to
	Groups *[]string `json:"groups,omitempty"`

	// Home The user's home directory
	Home *string `json:"home,omitempty"`

	// Key ssh public key
	Key  *string `json:"key,omitempty"`
	Name string  `json:"name"`

	// Password If the password starts with $6$, $5$, or $2b$ it will be stored as
	// an encrypted password. Otherwise it will be treated as a plain text
	// password.
	Password *string `json:"password,omitempty"`

	// Shell Login shell to use
	Shell *string `json:"shell,omitempty"`

	// Uid User id to use instead of the default
	Uid *int `json:"uid,omitempty"`
}

// BtrfsSubvolume defines model for BtrfsSubvolume.
type BtrfsSubvolume struct {
	// Mountpoint Mountpoint for the subvolume
	Mountpoint string `json:"mountpoint"`

	// Name The name of the subvolume, which defines the location (path) on the root volume
	Name string `json:"name"`
}

// BtrfsVolume defines model for BtrfsVolume.
type BtrfsVolume struct {
	// Minsize minimum size of the btrfs volume in bytes
	Minsize *uint64 `json:"minsize,omitempty"`

	// PartType The partition type GUID for GPT partitions. For DOS partitions, this field can be used to set the (2 hex digit) partition type. If not set, the type will be automatically set based on the mountpoint or the payload type.
	PartType   *string          `json:"part_type,omitempty"`
	Subvolumes []BtrfsSubvolume `json:"subvolumes"`
	Type       *BtrfsVolumeType `json:"type,omitempty"`
}

// BtrfsVolumeType defines model for BtrfsVolume.Type.
type BtrfsVolumeType string

// CACertsCustomization defines model for CACertsCustomization.
type CACertsCustomization struct {
	PemCerts []string `json:"pem_certs"`
}

// CloneComposeBody defines model for CloneComposeBody.
type CloneComposeBody struct {
	union json.RawMessage
}

// CloneComposeResponse defines model for CloneComposeResponse.
type CloneComposeResponse struct {
	Href string             `json:"href"`
	Id   openapi_types.UUID `json:"id"`
	Kind string             `json:"kind"`
}

// CloneStatus defines model for CloneStatus.
type CloneStatus struct {
	Href    string              `json:"href"`
	Id      string              `json:"id"`
	Kind    string              `json:"kind"`
	Options CloneStatus_Options `json:"options"`
	Status  UploadStatusValue   `json:"status"`
	Type    UploadTypes         `json:"type"`
}

// CloneStatus_Options defines model for CloneStatus.Options.
type CloneStatus_Options struct {
	union json.RawMessage
}

// ComposeId defines model for ComposeId.
type ComposeId struct {
	Href string             `json:"href"`
	Id   openapi_types.UUID `json:"id"`
	Kind string             `json:"kind"`
}

// ComposeList defines model for ComposeList.
type ComposeList struct {
	Items []ComposeStatus `json:"items"`
	Kind  string          `json:"kind"`
	Page  int             `json:"page"`
	Size  int             `json:"size"`
	Total int             `json:"total"`
}

// ComposeLogs defines model for ComposeLogs.
type ComposeLogs struct {
	Href        string        `json:"href"`
	Id          string        `json:"id"`
	ImageBuilds []interface{} `json:"image_builds"`
	Kind        string        `json:"kind"`
	Koji        *KojiLogs     `json:"koji,omitempty"`
}

// ComposeManifests defines model for ComposeManifests.
type ComposeManifests struct {
	Href      string        `json:"href"`
	Id        string        `json:"id"`
	Kind      string        `json:"kind"`
	Manifests []interface{} `json:"manifests"`
}

// ComposeMetadata defines model for ComposeMetadata.
type ComposeMetadata struct {
	Href string `json:"href"`
	Id   string `json:"id"`
	Kind string `json:"kind"`

	// OstreeCommit ID (hash) of the built commit
	OstreeCommit *string `json:"ostree_commit,omitempty"`

	// Packages Package list including NEVRA
	Packages *[]PackageMetadata `json:"packages,omitempty"`
	Request  *ComposeRequest    `json:"request,omitempty"`
}

// ComposeRequest defines model for ComposeRequest.
type ComposeRequest struct {
	Blueprint      *Blueprint      `json:"blueprint,omitempty"`
	Customizations *Customizations `json:"customizations,omitempty"`
	Distribution   string          `json:"distribution"`
	ImageRequest   *ImageRequest   `json:"image_request,omitempty"`
	ImageRequests  *[]ImageRequest `json:"image_requests,omitempty"`
	Koji           *Koji           `json:"koji,omitempty"`
}

// ComposeSBOMs defines model for ComposeSBOMs.
type ComposeSBOMs struct {
	Href string `json:"href"`
	Id   string `json:"id"`

	// Items The SBOM documents for each image built in the compose.
	Items [][]ImageSBOM `json:"items"`
	Kind  string        `json:"kind"`
}

// ComposeStatus defines model for ComposeStatus.
type ComposeStatus struct {
	Href          string             `json:"href"`
	Id            string             `json:"id"`
	ImageStatus   ImageStatus        `json:"image_status"`
	ImageStatuses *[]ImageStatus     `json:"image_statuses,omitempty"`
	Kind          string             `json:"kind"`
	KojiStatus    *KojiStatus        `json:"koji_status,omitempty"`
	Status        ComposeStatusValue `json:"status"`
}

// ComposeStatusError defines model for ComposeStatusError.
type ComposeStatusError struct {
	Details *interface{} `json:"details,omitempty"`
	Id      int          `json:"id"`
	Reason  string       `json:"reason"`
}

// ComposeStatusValue defines model for ComposeStatusValue.
type ComposeStatusValue string

// Container defines model for Container.
type Container struct {
	// Name Name to use for the container from the image
	Name *string `json:"name,omitempty"`

	// Source Reference to the container to embed
	Source string `json:"source"`

	// TlsVerify Control TLS verifification
	TlsVerify *bool `json:"tls_verify,omitempty"`
}

// ContainerUploadOptions defines model for ContainerUploadOptions.
type ContainerUploadOptions struct {
	// Name Name for the created container image
	Name *string `json:"name,omitempty"`

	// Tag Tag for the created container image
	Tag *string `json:"tag,omitempty"`
}

// ContainerUploadStatus defines model for ContainerUploadStatus.
type ContainerUploadStatus struct {
	// Digest Digest of the manifest of the uploaded container on the registry
	Digest string `json:"digest"`

	// Url FQDN of the uploaded image
	Url string `json:"url"`
}

// CustomRepository defines model for CustomRepository.
type CustomRepository struct {
	Baseurl        *[]string `json:"baseurl,omitempty"`
	CheckGpg       *bool     `json:"check_gpg,omitempty"`
	CheckRepoGpg   *bool     `json:"check_repo_gpg,omitempty"`
	Enabled        *bool     `json:"enabled,omitempty"`
	Filename       *string   `json:"filename,omitempty"`
	Gpgkey         *[]string `json:"gpgkey,omitempty"`
	Id             string    `json:"id"`
	Metalink       *string   `json:"metalink,omitempty"`
	Mirrorlist     *string   `json:"mirrorlist,omitempty"`
	ModuleHotfixes *bool     `json:"module_hotfixes,omitempty"`
	Name           *string   `json:"name,omitempty"`
	Priority       *int      `json:"priority,omitempty"`
	SslVerify      *bool     `json:"ssl_verify,omitempty"`
}

// Customizations defines model for Customizations.
type Customizations struct {
	Cacerts    *CACertsCustomization `json:"cacerts,omitempty"`
	Containers *[]Container          `json:"containers,omitempty"`

	// CustomRepositories Extra repositories for packages specified in customizations. These
	// repositories will be used to depsolve and retrieve packages. Additionally,
	// these packages will be saved and imported to the `/etc/yum.repos.d/` directory
	// on the image
	CustomRepositories *[]CustomRepository `json:"custom_repositories,omitempty"`
	Directories        *[]Directory        `json:"directories,omitempty"`
	Disk               *Disk               `json:"disk,omitempty"`
	EnabledModules     *[]Module           `json:"enabled_modules,omitempty"`

	// Fdo FIDO device onboard configuration
	Fdo        *FDO          `json:"fdo,omitempty"`
	Files      *[]File       `json:"files,omitempty"`
	Filesystem *[]Filesystem `json:"filesystem,omitempty"`

	// Fips System FIPS mode setup
	Fips *FIPS `json:"fips,omitempty"`

	// Firewall Firewalld configuration
	Firewall *FirewallCustomization `json:"firewall,omitempty"`

	// Groups List of groups to create
	Groups *[]Group `json:"groups,omitempty"`

	// Hostname Configures the hostname
	Hostname *string `json:"hostname,omitempty"`

	// Ignition Ignition configuration
	Ignition *Ignition `json:"ignition,omitempty"`

	// InstallationDevice Name of the installation device, currently only useful for the edge-simplified-installer type
	InstallationDevice *string    `json:"installation_device,omitempty"`
	Installer          *Installer `json:"installer,omitempty"`
	Kernel             *Kernel    `json:"kernel,omitempty"`

	// Locale Locale configuration
	Locale   *Locale   `json:"locale,omitempty"`
	Openscap *OpenSCAP `json:"openscap,omitempty"`
	Packages *[]string `json:"packages,omitempty"`

	// PartitioningMode Select how the disk image will be partitioned. 'auto-lvm' will use raw unless
	// there are one or more mountpoints in which case it will use LVM. 'lvm' always
	// uses LVM, even when there are no extra mountpoints. 'raw' uses raw partitions
	// even when there are one or more mountpoints.
	PartitioningMode *CustomizationsPartitioningMode `json:"partitioning_mode,omitempty"`

	// PayloadRepositories Extra repositories for packages specified in customizations. These
	// repositories will only be used to depsolve and retrieve packages
	// for the OS itself (they will not be available for the build root or
	// any other part of the build process). The package_sets field for these
	// repositories is ignored.
	PayloadRepositories *[]Repository      `json:"payload_repositories,omitempty"`
	Rhsm                *RHSMCustomization `json:"rhsm,omitempty"`
	Rpm                 *RPMCustomization  `json:"rpm,omitempty"`
	Services            *Services          `json:"services,omitempty"`
	Subscription        *Subscription      `json:"subscription,omitempty"`

	// Timezone Timezone configuration
	Timezone *Timezone `json:"timezone,omitempty"`
	Users    *[]User   `json:"users,omitempty"`
}

// CustomizationsPartitioningMode Select how the disk image will be partitioned. 'auto-lvm' will use raw unless
// there are one or more mountpoints in which case it will use LVM. 'lvm' always
// uses LVM, even when there are no extra mountpoints. 'raw' uses raw partitions
// even when there are one or more mountpoints.
type CustomizationsPartitioningMode string

// DNFPluginConfig defines model for DNFPluginConfig.
type DNFPluginConfig struct {
	Enabled *bool `json:"enabled,omitempty"`
}

// DepsolveRequest defines model for DepsolveRequest.
type DepsolveRequest struct {
	Architecture string        `json:"architecture"`
	Blueprint    Blueprint     `json:"blueprint"`
	Distribution string        `json:"distribution"`
	Repositories *[]Repository `json:"repositories,omitempty"`
}

// DepsolveResponse defines model for DepsolveResponse.
type DepsolveResponse struct {
	// Packages Package list including NEVRA
	Packages []PackageMetadataCommon `json:"packages"`
}

// Directory A custom directory to create in the final artifact.
type Directory struct {
	// EnsureParents Ensure that the parent directories exist
	EnsureParents *bool `json:"ensure_parents,omitempty"`

	// Group Group of the directory as a group name or a gid
	Group *Directory_Group `json:"group,omitempty"`

	// Mode Permissions string for the directory in octal format
	Mode *string `json:"mode,omitempty"`

	// Path Path to the directory
	Path string `json:"path"`

	// User Owner of the directory as a user name or a uid
	User *Directory_User `json:"user,omitempty"`
}

// DirectoryGroup0 defines model for .
type DirectoryGroup0 = string

// DirectoryGroup1 defines model for .
type DirectoryGroup1 = int64

// Directory_Group Group of the directory as a group name or a gid
type Directory_Group struct {
	union json.RawMessage
}

// DirectoryUser0 defines model for .
type DirectoryUser0 = string

// DirectoryUser1 defines model for .
type DirectoryUser1 = int64

// Directory_User Owner of the directory as a user name or a uid
type Directory_User struct {
	union json.RawMessage
}

// Disk defines model for Disk.
type Disk struct {
	// Minsize size of the filesystem in bytes
	Minsize    *uint64     `json:"minsize,omitempty"`
	Partitions []Partition `json:"partitions"`

	// Type Type of the partition table
	Type *DiskType `json:"type,omitempty"`
}

// DiskType Type of the partition table
type DiskType string

// DistributionList Map of distributions to their architecture.
type DistributionList map[string]map[string][]BlueprintRepository

// Error defines model for Error.
type Error struct {
	Code        string       `json:"code"`
	Details     *interface{} `json:"details,omitempty"`
	Href        string       `json:"href"`
	Id          string       `json:"id"`
	Kind        string       `json:"kind"`
	OperationId string       `json:"operation_id"`
	Reason      string       `json:"reason"`
}

// ErrorList defines model for ErrorList.
type ErrorList struct {
	Items []Error `json:"items"`
	Kind  string  `json:"kind"`
	Page  int     `json:"page"`
	Size  int     `json:"size"`
	Total int     `json:"total"`
}

// FDO FIDO device onboard configuration
type FDO struct {
	DiMfgStringTypeMacIface *string `json:"di_mfg_string_type_mac_iface,omitempty"`
	DiunPubKeyHash          *string `json:"diun_pub_key_hash,omitempty"`
	DiunPubKeyInsecure      *string `json:"diun_pub_key_insecure,omitempty"`
	DiunPubKeyRootCerts     *string `json:"diun_pub_key_root_certs,omitempty"`
	ManufacturingServerUrl  *string `json:"manufacturing_server_url,omitempty"`
}

// FIPS System FIPS mode setup
type FIPS struct {
	// Enabled Enables the system FIPS mode
	Enabled *bool `json:"enabled,omitempty"`
}

// File A custom file to create in the final artifact.
type File struct {
	// Data Contents of the file as plain text
	Data *string `json:"data,omitempty"`

	// EnsureParents Ensure that the parent directories exist
	EnsureParents *bool `json:"ensure_parents,omitempty"`

	// Group Group of the file as a gid or a group name
	Group *File_Group `json:"group,omitempty"`

	// Mode Permissions string for the file in octal format
	Mode *string `json:"mode,omitempty"`

	// Path Path to the file
	Path string `json:"path"`

	// User Owner of the file as a uid or a user name
	User *File_User `json:"user,omitempty"`
}

// FileGroup0 defines model for .
type FileGroup0 = string

// FileGroup1 defines model for .
type FileGroup1 = int64

// File_Group Group of the file as a gid or a group name
type File_Group struct {
	union json.RawMessage
}

// FileUser0 defines model for .
type FileUser0 = string

// FileUser1 defines model for .
type FileUser1 = int64

// File_User Owner of the file as a uid or a user name
type File_User struct {
	union json.RawMessage
}

// Filesystem defines model for Filesystem.
type Filesystem struct {
	// MinSize size of the filesystem in bytes
	MinSize    uint64 `json:"min_size"`
	Mountpoint string `json:"mountpoint"`
}

// FilesystemTyped defines model for FilesystemTyped.
type FilesystemTyped struct {
	// FsType The filesystem type
	FsType *FilesystemTypedFsType `json:"fs_type,omitempty"`
	Label  *string                `json:"label,omitempty"`

	// Minsize minimum size of the filesystem in bytes
	Minsize    *uint64 `json:"minsize,omitempty"`
	Mountpoint string  `json:"mountpoint"`

	// PartType The partition type GUID for GPT partitions. For DOS partitions, this field can be used to set the (2 hex digit) partition type. If not set, the type will be automatically set based on the mountpoint or the payload type.
	PartType *string              `json:"part_type,omitempty"`
	Type     *FilesystemTypedType `json:"type,omitempty"`
}

// FilesystemTypedFsType The filesystem type
type FilesystemTypedFsType string

// FilesystemTypedType defines model for FilesystemTyped.Type.
type FilesystemTypedType string

// FirewallCustomization Firewalld configuration
type FirewallCustomization struct {
	// Ports List of ports (or port ranges) and protocols to open
	Ports *[]string `json:"ports,omitempty"`

	// Services Firewalld services to enable or disable
	Services *FirewallServices `json:"services,omitempty"`
}

// FirewallServices Firewalld services to enable or disable
type FirewallServices struct {
	// Disabled List of services to disable
	Disabled *[]string `json:"disabled,omitempty"`

	// Enabled List of services to enable
	Enabled *[]string `json:"enabled,omitempty"`
}

// FirewallZones Bind a list of network sources to a zone to restrict traffic from
// those sources based on the settings of the zone.
type FirewallZones struct {
	// Name name of the zone, if left empty the sources will apply to
	// the default zone.
	Name *string `json:"name,omitempty"`

	// Sources List of sources for the zone
	Sources *[]string `json:"sources,omitempty"`
}

// GCPUploadOptions defines model for GCPUploadOptions.
type GCPUploadOptions struct {
	// Bucket Name of an existing STANDARD Storage class Bucket.
	Bucket *string `json:"bucket,omitempty"`

	// ImageName The name to use for the imported and shared Compute Engine image.
	// The image name must be unique within the GCP project, which is used
	// for the OS image upload and import. If not specified a random
	// 'composer-api-<uuid>' string is used as the image name.
	ImageName *string `json:"image_name,omitempty"`

	// Region The GCP region where the OS image will be imported to and shared from.
	// The value must be a valid GCP location. See https://cloud.google.com/storage/docs/locations.
	// If not specified, the multi-region location closest to the source
	// (source Storage Bucket location) is chosen automatically.
	Region string `json:"region"`

	// ShareWithAccounts List of valid Google accounts to share the imported Compute Engine image with.
	// Each string must contain a specifier of the account type. Valid formats are:
	//   - 'user:{emailid}': An email address that represents a specific
	//     Google account. For example, 'alice@example.com'.
	//   - 'serviceAccount:{emailid}': An email address that represents a
	//     service account. For example, 'my-other-app@appspot.gserviceaccount.com'.
	//   - 'group:{emailid}': An email address that represents a Google group.
	//     For example, 'admins@example.com'.
	//   - 'domain:{domain}': The G Suite domain (primary) that represents all
	//     the users of that domain. For example, 'google.com' or 'example.com'.
	// If not specified, the imported Compute Engine image is not shared with any
	// account.
	ShareWithAccounts *[]string `json:"share_with_accounts,omitempty"`
}

// GCPUploadStatus defines model for GCPUploadStatus.
type GCPUploadStatus struct {
	ImageName string `json:"image_name"`
	ProjectId string `json:"project_id"`
}

// Group defines model for Group.
type Group struct {
	// Gid Group id of the group to create (optional)
	Gid *int `json:"gid,omitempty"`

	// Name Name of the group to create
	Name string `json:"name"`
}

// Ignition Ignition configuration
type Ignition struct {
	Embedded  *IgnitionEmbedded  `json:"embedded,omitempty"`
	Firstboot *IgnitionFirstboot `json:"firstboot,omitempty"`
}

// IgnitionEmbedded defines model for IgnitionEmbedded.
type IgnitionEmbedded struct {
	Config string `json:"config"`
}

// IgnitionFirstboot defines model for IgnitionFirstboot.
type IgnitionFirstboot struct {
	// Url Provisioning URL
	Url string `json:"url"`
}

// ImageRequest defines model for ImageRequest.
type ImageRequest struct {
	Architecture string       `json:"architecture"`
	ImageType    ImageTypes   `json:"image_type"`
	Ostree       *OSTree      `json:"ostree,omitempty"`
	Repositories []Repository `json:"repositories"`

	// Size Size of image, in bytes. When set to 0 the image size is a minimum
	// defined by the image type.
	Size *uint64 `json:"size,omitempty"`

	// UploadOptions Options for a given upload destination.
	// This should really be oneOf but AWSS3UploadOptions is a subset of
	// AWSEC2UploadOptions. This means that all AWSEC2UploadOptions objects
	// are also valid AWSS3UploadOptionas objects which violates the oneOf
	// rules. Therefore, we have to use anyOf here but be aware that it isn't
	// possible to mix and match more schemas together.
	UploadOptions *UploadOptions `json:"upload_options,omitempty"`

	// UploadTargets The type and options for multiple upload targets. Each item defines
	// a separate upload destination with its own options. Multiple
	// different targets as well as multiple targets of the same kind are
	// supported.
	UploadTargets *[]UploadTarget `json:"upload_targets,omitempty"`
}

// ImageSBOM defines model for ImageSBOM.
type ImageSBOM struct {
	// PipelineName The name of the osbuild pipeline which has the packages described
	// in the SBOM installed.
	PipelineName string `json:"pipeline_name"`

	// PipelinePurpose The purpose of the pipeline. The `buildroot` pipeline was used for
	// the build environment dueing the image build. The `image` pipeline
	// represents the actual content of the image. Due to the nature of
	// some image types, there may be multiple pipelines of the same
	// purpose.
	PipelinePurpose ImageSBOMPipelinePurpose `json:"pipeline_purpose"`

	// Sbom The SBOM document in the 'sbom_type' format.
	Sbom interface{} `json:"sbom"`

	// SbomType The type of the SBOM document. Currently only SPDX is supported.
	SbomType ImageSBOMSbomType `json:"sbom_type"`
}

// ImageSBOMPipelinePurpose The purpose of the pipeline. The `buildroot` pipeline was used for
// the build environment dueing the image build. The `image` pipeline
// represents the actual content of the image. Due to the nature of
// some image types, there may be multiple pipelines of the same
// purpose.
type ImageSBOMPipelinePurpose string

// ImageSBOMSbomType The type of the SBOM document. Currently only SPDX is supported.
type ImageSBOMSbomType string

// ImageStatus defines model for ImageStatus.
type ImageStatus struct {
	Error          *ComposeStatusError `json:"error,omitempty"`
	Status         ImageStatusValue    `json:"status"`
	UploadStatus   *UploadStatus       `json:"upload_status,omitempty"`
	UploadStatuses *[]UploadStatus     `json:"upload_statuses,omitempty"`
}

// ImageStatusValue defines model for ImageStatusValue.
type ImageStatusValue string

// ImageTypes defines model for ImageTypes.
type ImageTypes string

// ImportKeys defines model for ImportKeys.
type ImportKeys struct {
	Files *[]string `json:"files,omitempty"`
}

// Installer defines model for Installer.
type Installer struct {
	SudoNopasswd *[]string `json:"sudo-nopasswd,omitempty"`
	Unattended   *bool     `json:"unattended,omitempty"`
}

// Kernel defines model for Kernel.
type Kernel struct {
	// Append Appends arguments to the bootloader kernel command line
	Append *string `json:"append,omitempty"`

	// Name Name of the kernel to use
	Name *string `json:"name,omitempty"`
}

// Koji defines model for Koji.
type Koji struct {
	Name    string `json:"name"`
	Release string `json:"release"`
	Server  string `json:"server"`
	TaskId  int    `json:"task_id"`
	Version string `json:"version"`
}

// KojiLogs defines model for KojiLogs.
type KojiLogs struct {
	Import interface{} `json:"import"`
	Init   interface{} `json:"init"`
}

// KojiStatus defines model for KojiStatus.
type KojiStatus struct {
	BuildId *int `json:"build_id,omitempty"`
}

// List defines model for List.
type List struct {
	Kind  string `json:"kind"`
	Page  int    `json:"page"`
	Size  int    `json:"size"`
	Total int    `json:"total"`
}

// LocalUploadOptions defines model for LocalUploadOptions.
type LocalUploadOptions = map[string]interface{}

// LocalUploadStatus defines model for LocalUploadStatus.
type LocalUploadStatus struct {
	ArtifactPath string `json:"artifact_path"`
}

// Locale Locale configuration
type Locale struct {
	// Keyboard Sets the keyboard layout
	Keyboard *string `json:"keyboard,omitempty"`

	// Languages List of locales to be installed, the first one becomes primary, subsequent ones are secondary
	Languages *[]string `json:"languages,omitempty"`
}

// LogicalVolume defines model for LogicalVolume.
type LogicalVolume struct {
	// FsType The filesystem type for the logical volume
	FsType *LogicalVolumeFsType `json:"fs_type,omitempty"`
	Label  *string              `json:"label,omitempty"`

	// Minsize minimum size of the logical volume in bytes
	Minsize *uint64 `json:"minsize,omitempty"`

	// Mountpoint Mountpoint for the logical volume
	Mountpoint string  `json:"mountpoint"`
	Name       *string `json:"name,omitempty"`
}

// LogicalVolumeFsType The filesystem type for the logical volume
type LogicalVolumeFsType string

// Module defines model for Module.
type Module struct {
	// Name Name of the module to enable.
	Name string `json:"name"`

	// Stream Stream to enable.
	Stream string `json:"stream"`
}

// OCIUploadOptions defines model for OCIUploadOptions.
type OCIUploadOptions = map[string]interface{}

// OCIUploadStatus defines model for OCIUploadStatus.
type OCIUploadStatus struct {
	Url string `json:"url"`
}

// OSTree defines model for OSTree.
type OSTree struct {
	// Contenturl A URL which, if set, is used for fetching content. Implies that `url` is set as well,
	// which will be used for metadata only.
	Contenturl *string `json:"contenturl,omitempty"`

	// Parent Can be either a commit (example: 02604b2da6e954bd34b8b82a835e5a77d2b60ffa), or a branch-like reference (example: rhel/8/x86_64/edge)
	Parent *string `json:"parent,omitempty"`
	Ref    *string `json:"ref,omitempty"`

	// Rhsm Determines whether a valid subscription manager (candlepin) identity is required to
	// access this repository. Consumer certificates will be used as client certificates when
	// fetching metadata and content.
	Rhsm *bool   `json:"rhsm,omitempty"`
	Url  *string `json:"url,omitempty"`
}

// ObjectReference defines model for ObjectReference.
type ObjectReference struct {
	Href string `json:"href"`
	Id   string `json:"id"`
	Kind string `json:"kind"`
}

// OpenSCAP defines model for OpenSCAP.
type OpenSCAP struct {
	JsonTailoring *OpenSCAPJSONTailoring `json:"json_tailoring,omitempty"`

	// PolicyId Puts a specified policy ID in the RHSM facts, so that any instances registered to
	// insights will be automatically connected to the compliance policy in the console.
	PolicyId  *openapi_types.UUID `json:"policy_id,omitempty"`
	ProfileId string              `json:"profile_id"`
	Tailoring *OpenSCAPTailoring  `json:"tailoring,omitempty"`
}

// OpenSCAPJSONTailoring defines model for OpenSCAPJSONTailoring.
type OpenSCAPJSONTailoring struct {
	Filepath  string `json:"filepath"`
	ProfileId string `json:"profile_id"`
}

// OpenSCAPTailoring defines model for OpenSCAPTailoring.
type OpenSCAPTailoring struct {
	Selected   *[]string `json:"selected,omitempty"`
	Unselected *[]string `json:"unselected,omitempty"`
}

// Package defines model for Package.
type Package struct {
	// Name Name of the package to install. File globbing is supported,
	// eg. 'openssh-*'
	Name string `json:"name"`

	// Version Optional version of the package to install. If left blank the
	// latest available version will be used. Wildcards are supported
	// eg. '4.11.*'
	Version *string `json:"version,omitempty"`
}

// PackageDetails defines model for PackageDetails.
type PackageDetails struct {
	Arch        string  `json:"arch"`
	Buildtime   *string `json:"buildtime,omitempty"`
	Description *string `json:"description,omitempty"`
	Epoch       *string `json:"epoch,omitempty"`
	License     *string `json:"license,omitempty"`
	Name        string  `json:"name"`
	Release     string  `json:"release"`
	Summary     *string `json:"summary,omitempty"`
	Url         *string `json:"url,omitempty"`
	Version     string  `json:"version"`
}

// PackageGroup defines model for PackageGroup.
type PackageGroup struct {
	// Name Package group name
	Name string `json:"name"`
}

// PackageMetadata defines model for PackageMetadata.
type PackageMetadata struct {
	Arch string `json:"arch"`

	// Checksum Optional package checksum using ALGO:HASH form
	Checksum  *string `json:"checksum,omitempty"`
	Epoch     *string `json:"epoch,omitempty"`
	Name      string  `json:"name"`
	Release   string  `json:"release"`
	Sigmd5    string  `json:"sigmd5"`
	Signature *string `json:"signature,omitempty"`
	Type      string  `json:"type"`
	Version   string  `json:"version"`
}

// PackageMetadataCommon defines model for PackageMetadataCommon.
type PackageMetadataCommon struct {
	Arch string `json:"arch"`

	// Checksum Optional package checksum using ALGO:HASH form
	Checksum  *string `json:"checksum,omitempty"`
	Epoch     *string `json:"epoch,omitempty"`
	Name      string  `json:"name"`
	Release   string  `json:"release"`
	Signature *string `json:"signature,omitempty"`
	Type      string  `json:"type"`
	Version   string  `json:"version"`
}

// Partition defines model for Partition.
type Partition struct {
	union json.RawMessage
}

// PulpOSTreeUploadOptions defines model for PulpOSTreeUploadOptions.
type PulpOSTreeUploadOptions struct {
	// Basepath Basepath for distributing the repository
	Basepath string `json:"basepath"`

	// Repository Repository to import the ostree commit to
	Repository    *string `json:"repository,omitempty"`
	ServerAddress *string `json:"server_address,omitempty"`
}

// PulpOSTreeUploadStatus defines model for PulpOSTreeUploadStatus.
type PulpOSTreeUploadStatus struct {
	RepoUrl string `json:"repo_url"`
}

// RHSMConfig defines model for RHSMConfig.
type RHSMConfig struct {
	DnfPlugins          *SubManDNFPluginsConfig `json:"dnf_plugins,omitempty"`
	SubscriptionManager *SubManConfig           `json:"subscription_manager,omitempty"`
}

// RHSMCustomization defines model for RHSMCustomization.
type RHSMCustomization struct {
	Config *RHSMConfig `json:"config,omitempty"`
}

// RPMCustomization defines model for RPMCustomization.
type RPMCustomization struct {
	ImportKeys *ImportKeys `json:"import_keys,omitempty"`
}

// Repository Repository configuration.
// At least one of the 'baseurl', 'mirrorlist', 'metalink' properties must
// be specified. If more of them are specified, the order of precedence is
// the same as listed above.
type Repository struct {
	Baseurl  *string `json:"baseurl,omitempty"`
	CheckGpg *bool   `json:"check_gpg,omitempty"`

	// CheckRepoGpg Enables gpg verification of the repository metadata
	CheckRepoGpg *bool `json:"check_repo_gpg,omitempty"`

	// Gpgkey GPG key used to sign packages in this repository.
	Gpgkey     *string `json:"gpgkey,omitempty"`
	IgnoreSsl  *bool   `json:"ignore_ssl,omitempty"`
	Metalink   *string `json:"metalink,omitempty"`
	Mirrorlist *string `json:"mirrorlist,omitempty"`

	// ModuleHotfixes Disables modularity filtering for this repository.
	ModuleHotfixes *bool `json:"module_hotfixes,omitempty"`

	// PackageSets Naming package sets for a repository assigns it to a specific part
	// (pipeline) of the build process.
	PackageSets *[]string `json:"package_sets,omitempty"`

	// Rhsm Determines whether a valid subscription is required to access this repository.
	Rhsm *bool `json:"rhsm,omitempty"`
}

// SSHKey defines model for SSHKey.
type SSHKey struct {
	// Key Adds the key to the user's authorized_keys file
	Key string `json:"key"`

	// User User to configure the ssh key for
	User string `json:"user"`
}

// SearchPackagesRequest defines model for SearchPackagesRequest.
type SearchPackagesRequest struct {
	Architecture string `json:"architecture"`
	Distribution string `json:"distribution"`

	// Packages Array of package names to search for. Supports * wildcards for
	// names, but not for versions.
	Packages     []string      `json:"packages"`
	Repositories *[]Repository `json:"repositories,omitempty"`
}

// SearchPackagesResponse defines model for SearchPackagesResponse.
type SearchPackagesResponse struct {
	// Packages Detailed package information from DNF
	Packages []PackageDetails `json:"packages"`
}

// Services defines model for Services.
type Services struct {
	// Disabled List of services to disable by default
	Disabled *[]string `json:"disabled,omitempty"`

	// Enabled List of services to enable by default
	Enabled *[]string `json:"enabled,omitempty"`

	// Masked List of services to mask by default
	Masked *[]string `json:"masked,omitempty"`
}

// SubManConfig defines model for SubManConfig.
type SubManConfig struct {
	Rhsm      *SubManRHSMConfig      `json:"rhsm,omitempty"`
	Rhsmcertd *SubManRHSMCertdConfig `json:"rhsmcertd,omitempty"`
}

// SubManDNFPluginsConfig defines model for SubManDNFPluginsConfig.
type SubManDNFPluginsConfig struct {
	ProductId           *DNFPluginConfig `json:"product_id,omitempty"`
	SubscriptionManager *DNFPluginConfig `json:"subscription_manager,omitempty"`
}

// SubManRHSMCertdConfig defines model for SubManRHSMCertdConfig.
type SubManRHSMCertdConfig struct {
	AutoRegistration *bool `json:"auto_registration,omitempty"`
}

// SubManRHSMConfig defines model for SubManRHSMConfig.
type SubManRHSMConfig struct {
	ManageRepos *bool `json:"manage_repos,omitempty"`
}

// Subscription defines model for Subscription.
type Subscription struct {
	ActivationKey string `json:"activation_key"`
	BaseUrl       string `json:"base_url"`
	Insights      bool   `json:"insights"`
	Organization  string `json:"organization"`

	// Rhc Optional flag to use rhc to register the system, which also always enables Insights.
	Rhc       *bool  `json:"rhc,omitempty"`
	ServerUrl string `json:"server_url"`
}

// Timezone Timezone configuration
type Timezone struct {
	// Ntpservers List of ntp servers
	Ntpservers *[]string `json:"ntpservers,omitempty"`

	// Timezone Name of the timezone, defaults to UTC
	Timezone *string `json:"timezone,omitempty"`
}

// UploadOptions Options for a given upload destination.
// This should really be oneOf but AWSS3UploadOptions is a subset of
// AWSEC2UploadOptions. This means that all AWSEC2UploadOptions objects
// are also valid AWSS3UploadOptionas objects which violates the oneOf
// rules. Therefore, we have to use anyOf here but be aware that it isn't
// possible to mix and match more schemas together.
type UploadOptions struct {
	union json.RawMessage
}

// UploadStatus defines model for UploadStatus.
type UploadStatus struct {
	Options UploadStatus_Options `json:"options"`
	Status  UploadStatusValue    `json:"status"`
	Type    UploadTypes          `json:"type"`
}

// UploadStatus_Options defines model for UploadStatus.Options.
type UploadStatus_Options struct {
	union json.RawMessage
}

// UploadStatusValue defines model for UploadStatusValue.
type UploadStatusValue string

// UploadTarget defines model for UploadTarget.
type UploadTarget struct {
	Type UploadTypes `json:"type"`

	// UploadOptions Options for a given upload destination.
	// This should really be oneOf but AWSS3UploadOptions is a subset of
	// AWSEC2UploadOptions. This means that all AWSEC2UploadOptions objects
	// are also valid AWSS3UploadOptionas objects which violates the oneOf
	// rules. Therefore, we have to use anyOf here but be aware that it isn't
	// possible to mix and match more schemas together.
	UploadOptions UploadOptions `json:"upload_options"`
}

// UploadTypes defines model for UploadTypes.
type UploadTypes string

// User defines model for User.
type User struct {
	Groups *[]string `json:"groups,omitempty"`
	Key    *string   `json:"key,omitempty"`
	Name   string    `json:"name"`

	// Password If the password starts with $6$, $5$, or $2b$ it will be stored as
	// an encrypted password. Otherwise it will be treated as a plain text
	// password.
	Password *string `json:"password,omitempty"`
}

// VolumeGroup defines model for VolumeGroup.
type VolumeGroup struct {
	LogicalVolumes []LogicalVolume `json:"logical_volumes"`

	// Minsize minimum size of the volume group in bytes
	Minsize *uint64 `json:"minsize,omitempty"`

	// Name Volume group name (will be automatically generated if omitted)
	Name *string `json:"name,omitempty"`

	// PartType The partition type GUID for GPT partitions. For DOS partitions, this field can be used to set the (2 hex digit) partition type. If not set, the type will be automatically set based on the mountpoint or the payload type.
	PartType *string          `json:"part_type,omitempty"`
	Type     *VolumeGroupType `json:"type,omitempty"`
}

// VolumeGroupType defines model for VolumeGroup.Type.
type VolumeGroupType string

// Page defines model for page.
type Page = string

// Size defines model for size.
type Size = string

// GetErrorListParams defines parameters for GetErrorList.
type GetErrorListParams struct {
	// Page Page index
	Page *Page `form:"page,omitempty" json:"page,omitempty"`

	// Size Number of items in each page
	Size *Size `form:"size,omitempty" json:"size,omitempty"`
}

// PostComposeJSONRequestBody defines body for PostCompose for application/json ContentType.
type PostComposeJSONRequestBody = ComposeRequest

// PostCloneComposeJSONRequestBody defines body for PostCloneCompose for application/json ContentType.
type PostCloneComposeJSONRequestBody = CloneComposeBody

// PostDepsolveBlueprintJSONRequestBody defines body for PostDepsolveBlueprint for application/json ContentType.
type PostDepsolveBlueprintJSONRequestBody = DepsolveRequest

// PostSearchPackagesJSONRequestBody defines body for PostSearchPackages for application/json ContentType.
type PostSearchPackagesJSONRequestBody = SearchPackagesRequest

// AsBlueprintFileGroup0 returns the union data inside the BlueprintFile_Group as a BlueprintFileGroup0
func (t BlueprintFile_Group) AsBlueprintFileGroup0() (BlueprintFileGroup0, error) {
	var body BlueprintFileGroup0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromBlueprintFileGroup0 overwrites any union data inside the BlueprintFile_Group as the provided BlueprintFileGroup0
func (t *BlueprintFile_Group) FromBlueprintFileGroup0(v BlueprintFileGroup0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeBlueprintFileGroup0 performs a merge with any union data inside the BlueprintFile_Group, using the provided BlueprintFileGroup0
func (t *BlueprintFile_Group) MergeBlueprintFileGroup0(v BlueprintFileGroup0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsBlueprintFileGroup1 returns the union data inside the BlueprintFile_Group as a BlueprintFileGroup1
func (t BlueprintFile_Group) AsBlueprintFileGroup1() (BlueprintFileGroup1, error) {
	var body BlueprintFileGroup1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromBlueprintFileGroup1 overwrites any union data inside the BlueprintFile_Group as the provided BlueprintFileGroup1
func (t *BlueprintFile_Group) FromBlueprintFileGroup1(v BlueprintFileGroup1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeBlueprintFileGroup1 performs a merge with any union data inside the BlueprintFile_Group, using the provided BlueprintFileGroup1
func (t *BlueprintFile_Group) MergeBlueprintFileGroup1(v BlueprintFileGroup1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t BlueprintFile_Group) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *BlueprintFile_Group) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsBlueprintFileUser0 returns the union data inside the BlueprintFile_User as a BlueprintFileUser0
func (t BlueprintFile_User) AsBlueprintFileUser0() (BlueprintFileUser0, error) {
	var body BlueprintFileUser0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromBlueprintFileUser0 overwrites any union data inside the BlueprintFile_User as the provided BlueprintFileUser0
func (t *BlueprintFile_User) FromBlueprintFileUser0(v BlueprintFileUser0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeBlueprintFileUser0 performs a merge with any union data inside the BlueprintFile_User, using the provided BlueprintFileUser0
func (t *BlueprintFile_User) MergeBlueprintFileUser0(v BlueprintFileUser0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsBlueprintFileUser1 returns the union data inside the BlueprintFile_User as a BlueprintFileUser1
func (t BlueprintFile_User) AsBlueprintFileUser1() (BlueprintFileUser1, error) {
	var body BlueprintFileUser1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromBlueprintFileUser1 overwrites any union data inside the BlueprintFile_User as the provided BlueprintFileUser1
func (t *BlueprintFile_User) FromBlueprintFileUser1(v BlueprintFileUser1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeBlueprintFileUser1 performs a merge with any union data inside the BlueprintFile_User, using the provided BlueprintFileUser1
func (t *BlueprintFile_User) MergeBlueprintFileUser1(v BlueprintFileUser1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t BlueprintFile_User) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *BlueprintFile_User) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsAWSEC2CloneCompose returns the union data inside the CloneComposeBody as a AWSEC2CloneCompose
func (t CloneComposeBody) AsAWSEC2CloneCompose() (AWSEC2CloneCompose, error) {
	var body AWSEC2CloneCompose
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAWSEC2CloneCompose overwrites any union data inside the CloneComposeBody as the provided AWSEC2CloneCompose
func (t *CloneComposeBody) FromAWSEC2CloneCompose(v AWSEC2CloneCompose) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAWSEC2CloneCompose performs a merge with any union data inside the CloneComposeBody, using the provided AWSEC2CloneCompose
func (t *CloneComposeBody) MergeAWSEC2CloneCompose(v AWSEC2CloneCompose) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t CloneComposeBody) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *CloneComposeBody) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsAWSEC2UploadStatus returns the union data inside the CloneStatus_Options as a AWSEC2UploadStatus
func (t CloneStatus_Options) AsAWSEC2UploadStatus() (AWSEC2UploadStatus, error) {
	var body AWSEC2UploadStatus
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAWSEC2UploadStatus overwrites any union data inside the CloneStatus_Options as the provided AWSEC2UploadStatus
func (t *CloneStatus_Options) FromAWSEC2UploadStatus(v AWSEC2UploadStatus) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAWSEC2UploadStatus performs a merge with any union data inside the CloneStatus_Options, using the provided AWSEC2UploadStatus
func (t *CloneStatus_Options) MergeAWSEC2UploadStatus(v AWSEC2UploadStatus) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsAWSS3UploadStatus returns the union data inside the CloneStatus_Options as a AWSS3UploadStatus
func (t CloneStatus_Options) AsAWSS3UploadStatus() (AWSS3UploadStatus, error) {
	var body AWSS3UploadStatus
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAWSS3UploadStatus overwrites any union data inside the CloneStatus_Options as the provided AWSS3UploadStatus
func (t *CloneStatus_Options) FromAWSS3UploadStatus(v AWSS3UploadStatus) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAWSS3UploadStatus performs a merge with any union data inside the CloneStatus_Options, using the provided AWSS3UploadStatus
func (t *CloneStatus_Options) MergeAWSS3UploadStatus(v AWSS3UploadStatus) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsGCPUploadStatus returns the union data inside the CloneStatus_Options as a GCPUploadStatus
func (t CloneStatus_Options) AsGCPUploadStatus() (GCPUploadStatus, error) {
	var body GCPUploadStatus
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromGCPUploadStatus overwrites any union data inside the CloneStatus_Options as the provided GCPUploadStatus
func (t *CloneStatus_Options) FromGCPUploadStatus(v GCPUploadStatus) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeGCPUploadStatus performs a merge with any union data inside the CloneStatus_Options, using the provided GCPUploadStatus
func (t *CloneStatus_Options) MergeGCPUploadStatus(v GCPUploadStatus) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsAzureUploadStatus returns the union data inside the CloneStatus_Options as a AzureUploadStatus
func (t CloneStatus_Options) AsAzureUploadStatus() (AzureUploadStatus, error) {
	var body AzureUploadStatus
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAzureUploadStatus overwrites any union data inside the CloneStatus_Options as the provided AzureUploadStatus
func (t *CloneStatus_Options) FromAzureUploadStatus(v AzureUploadStatus) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAzureUploadStatus performs a merge with any union data inside the CloneStatus_Options, using the provided AzureUploadStatus
func (t *CloneStatus_Options) MergeAzureUploadStatus(v AzureUploadStatus) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsContainerUploadStatus returns the union data inside the CloneStatus_Options as a ContainerUploadStatus
func (t CloneStatus_Options) AsContainerUploadStatus() (ContainerUploadStatus, error) {
	var body ContainerUploadStatus
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromContainerUploadStatus overwrites any union data inside the CloneStatus_Options as the provided ContainerUploadStatus
func (t *CloneStatus_Options) FromContainerUploadStatus(v ContainerUploadStatus) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeContainerUploadStatus performs a merge with any union data inside the CloneStatus_Options, using the provided ContainerUploadStatus
func (t *CloneStatus_Options) MergeContainerUploadStatus(v ContainerUploadStatus) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsOCIUploadStatus returns the union data inside the CloneStatus_Options as a OCIUploadStatus
func (t CloneStatus_Options) AsOCIUploadStatus() (OCIUploadStatus, error) {
	var body OCIUploadStatus
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromOCIUploadStatus overwrites any union data inside the CloneStatus_Options as the provided OCIUploadStatus
func (t *CloneStatus_Options) FromOCIUploadStatus(v OCIUploadStatus) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeOCIUploadStatus performs a merge with any union data inside the CloneStatus_Options, using the provided OCIUploadStatus
func (t *CloneStatus_Options) MergeOCIUploadStatus(v OCIUploadStatus) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPulpOSTreeUploadStatus returns the union data inside the CloneStatus_Options as a PulpOSTreeUploadStatus
func (t CloneStatus_Options) AsPulpOSTreeUploadStatus() (PulpOSTreeUploadStatus, error) {
	var body PulpOSTreeUploadStatus
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPulpOSTreeUploadStatus overwrites any union data inside the CloneStatus_Options as the provided PulpOSTreeUploadStatus
func (t *CloneStatus_Options) FromPulpOSTreeUploadStatus(v PulpOSTreeUploadStatus) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePulpOSTreeUploadStatus performs a merge with any union data inside the CloneStatus_Options, using the provided PulpOSTreeUploadStatus
func (t *CloneStatus_Options) MergePulpOSTreeUploadStatus(v PulpOSTreeUploadStatus) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsLocalUploadStatus returns the union data inside the CloneStatus_Options as a LocalUploadStatus
func (t CloneStatus_Options) AsLocalUploadStatus() (LocalUploadStatus, error) {
	var body LocalUploadStatus
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromLocalUploadStatus overwrites any union data inside the CloneStatus_Options as the provided LocalUploadStatus
func (t *CloneStatus_Options) FromLocalUploadStatus(v LocalUploadStatus) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeLocalUploadStatus performs a merge with any union data inside the CloneStatus_Options, using the provided LocalUploadStatus
func (t *CloneStatus_Options) MergeLocalUploadStatus(v LocalUploadStatus) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t CloneStatus_Options) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *CloneStatus_Options) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsDirectoryGroup0 returns the union data inside the Directory_Group as a DirectoryGroup0
func (t Directory_Group) AsDirectoryGroup0() (DirectoryGroup0, error) {
	var body DirectoryGroup0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromDirectoryGroup0 overwrites any union data inside the Directory_Group as the provided DirectoryGroup0
func (t *Directory_Group) FromDirectoryGroup0(v DirectoryGroup0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeDirectoryGroup0 performs a merge with any union data inside the Directory_Group, using the provided DirectoryGroup0
func (t *Directory_Group) MergeDirectoryGroup0(v DirectoryGroup0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsDirectoryGroup1 returns the union data inside the Directory_Group as a DirectoryGroup1
func (t Directory_Group) AsDirectoryGroup1() (DirectoryGroup1, error) {
	var body DirectoryGroup1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromDirectoryGroup1 overwrites any union data inside the Directory_Group as the provided DirectoryGroup1
func (t *Directory_Group) FromDirectoryGroup1(v DirectoryGroup1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeDirectoryGroup1 performs a merge with any union data inside the Directory_Group, using the provided DirectoryGroup1
func (t *Directory_Group) MergeDirectoryGroup1(v DirectoryGroup1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t Directory_Group) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *Directory_Group) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsDirectoryUser0 returns the union data inside the Directory_User as a DirectoryUser0
func (t Directory_User) AsDirectoryUser0() (DirectoryUser0, error) {
	var body DirectoryUser0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromDirectoryUser0 overwrites any union data inside the Directory_User as the provided DirectoryUser0
func (t *Directory_User) FromDirectoryUser0(v DirectoryUser0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeDirectoryUser0 performs a merge with any union data inside the Directory_User, using the provided DirectoryUser0
func (t *Directory_User) MergeDirectoryUser0(v DirectoryUser0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsDirectoryUser1 returns the union data inside the Directory_User as a DirectoryUser1
func (t Directory_User) AsDirectoryUser1() (DirectoryUser1, error) {
	var body DirectoryUser1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromDirectoryUser1 overwrites any union data inside the Directory_User as the provided DirectoryUser1
func (t *Directory_User) FromDirectoryUser1(v DirectoryUser1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeDirectoryUser1 performs a merge with any union data inside the Directory_User, using the provided DirectoryUser1
func (t *Directory_User) MergeDirectoryUser1(v DirectoryUser1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t Directory_User) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *Directory_User) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsFileGroup0 returns the union data inside the File_Group as a FileGroup0
func (t File_Group) AsFileGroup0() (FileGroup0, error) {
	var body FileGroup0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromFileGroup0 overwrites any union data inside the File_Group as the provided FileGroup0
func (t *File_Group) FromFileGroup0(v FileGroup0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeFileGroup0 performs a merge with any union data inside the File_Group, using the provided FileGroup0
func (t *File_Group) MergeFileGroup0(v FileGroup0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsFileGroup1 returns the union data inside the File_Group as a FileGroup1
func (t File_Group) AsFileGroup1() (FileGroup1, error) {
	var body FileGroup1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromFileGroup1 overwrites any union data inside the File_Group as the provided FileGroup1
func (t *File_Group) FromFileGroup1(v FileGroup1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeFileGroup1 performs a merge with any union data inside the File_Group, using the provided FileGroup1
func (t *File_Group) MergeFileGroup1(v FileGroup1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t File_Group) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *File_Group) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsFileUser0 returns the union data inside the File_User as a FileUser0
func (t File_User) AsFileUser0() (FileUser0, error) {
	var body FileUser0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromFileUser0 overwrites any union data inside the File_User as the provided FileUser0
func (t *File_User) FromFileUser0(v FileUser0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeFileUser0 performs a merge with any union data inside the File_User, using the provided FileUser0
func (t *File_User) MergeFileUser0(v FileUser0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsFileUser1 returns the union data inside the File_User as a FileUser1
func (t File_User) AsFileUser1() (FileUser1, error) {
	var body FileUser1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromFileUser1 overwrites any union data inside the File_User as the provided FileUser1
func (t *File_User) FromFileUser1(v FileUser1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeFileUser1 performs a merge with any union data inside the File_User, using the provided FileUser1
func (t *File_User) MergeFileUser1(v FileUser1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t File_User) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *File_User) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsFilesystemTyped returns the union data inside the Partition as a FilesystemTyped
func (t Partition) AsFilesystemTyped() (FilesystemTyped, error) {
	var body FilesystemTyped
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromFilesystemTyped overwrites any union data inside the Partition as the provided FilesystemTyped
func (t *Partition) FromFilesystemTyped(v FilesystemTyped) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeFilesystemTyped performs a merge with any union data inside the Partition, using the provided FilesystemTyped
func (t *Partition) MergeFilesystemTyped(v FilesystemTyped) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsBtrfsVolume returns the union data inside the Partition as a BtrfsVolume
func (t Partition) AsBtrfsVolume() (BtrfsVolume, error) {
	var body BtrfsVolume
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromBtrfsVolume overwrites any union data inside the Partition as the provided BtrfsVolume
func (t *Partition) FromBtrfsVolume(v BtrfsVolume) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeBtrfsVolume performs a merge with any union data inside the Partition, using the provided BtrfsVolume
func (t *Partition) MergeBtrfsVolume(v BtrfsVolume) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsVolumeGroup returns the union data inside the Partition as a VolumeGroup
func (t Partition) AsVolumeGroup() (VolumeGroup, error) {
	var body VolumeGroup
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromVolumeGroup overwrites any union data inside the Partition as the provided VolumeGroup
func (t *Partition) FromVolumeGroup(v VolumeGroup) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeVolumeGroup performs a merge with any union data inside the Partition, using the provided VolumeGroup
func (t *Partition) MergeVolumeGroup(v VolumeGroup) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t Partition) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *Partition) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsAWSEC2UploadOptions returns the union data inside the UploadOptions as a AWSEC2UploadOptions
func (t UploadOptions) AsAWSEC2UploadOptions() (AWSEC2UploadOptions, error) {
	var body AWSEC2UploadOptions
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAWSEC2UploadOptions overwrites any union data inside the UploadOptions as the provided AWSEC2UploadOptions
func (t *UploadOptions) FromAWSEC2UploadOptions(v AWSEC2UploadOptions) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAWSEC2UploadOptions performs a merge with any union data inside the UploadOptions, using the provided AWSEC2UploadOptions
func (t *UploadOptions) MergeAWSEC2UploadOptions(v AWSEC2UploadOptions) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsAWSS3UploadOptions returns the union data inside the UploadOptions as a AWSS3UploadOptions
func (t UploadOptions) AsAWSS3UploadOptions() (AWSS3UploadOptions, error) {
	var body AWSS3UploadOptions
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAWSS3UploadOptions overwrites any union data inside the UploadOptions as the provided AWSS3UploadOptions
func (t *UploadOptions) FromAWSS3UploadOptions(v AWSS3UploadOptions) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAWSS3UploadOptions performs a merge with any union data inside the UploadOptions, using the provided AWSS3UploadOptions
func (t *UploadOptions) MergeAWSS3UploadOptions(v AWSS3UploadOptions) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsGCPUploadOptions returns the union data inside the UploadOptions as a GCPUploadOptions
func (t UploadOptions) AsGCPUploadOptions() (GCPUploadOptions, error) {
	var body GCPUploadOptions
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromGCPUploadOptions overwrites any union data inside the UploadOptions as the provided GCPUploadOptions
func (t *UploadOptions) FromGCPUploadOptions(v GCPUploadOptions) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeGCPUploadOptions performs a merge with any union data inside the UploadOptions, using the provided GCPUploadOptions
func (t *UploadOptions) MergeGCPUploadOptions(v GCPUploadOptions) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsAzureUploadOptions returns the union data inside the UploadOptions as a AzureUploadOptions
func (t UploadOptions) AsAzureUploadOptions() (AzureUploadOptions, error) {
	var body AzureUploadOptions
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAzureUploadOptions overwrites any union data inside the UploadOptions as the provided AzureUploadOptions
func (t *UploadOptions) FromAzureUploadOptions(v AzureUploadOptions) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAzureUploadOptions performs a merge with any union data inside the UploadOptions, using the provided AzureUploadOptions
func (t *UploadOptions) MergeAzureUploadOptions(v AzureUploadOptions) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsContainerUploadOptions returns the union data inside the UploadOptions as a ContainerUploadOptions
func (t UploadOptions) AsContainerUploadOptions() (ContainerUploadOptions, error) {
	var body ContainerUploadOptions
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromContainerUploadOptions overwrites any union data inside the UploadOptions as the provided ContainerUploadOptions
func (t *UploadOptions) FromContainerUploadOptions(v ContainerUploadOptions) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeContainerUploadOptions performs a merge with any union data inside the UploadOptions, using the provided ContainerUploadOptions
func (t *UploadOptions) MergeContainerUploadOptions(v ContainerUploadOptions) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsLocalUploadOptions returns the union data inside the UploadOptions as a LocalUploadOptions
func (t UploadOptions) AsLocalUploadOptions() (LocalUploadOptions, error) {
	var body LocalUploadOptions
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromLocalUploadOptions overwrites any union data inside the UploadOptions as the provided LocalUploadOptions
func (t *UploadOptions) FromLocalUploadOptions(v LocalUploadOptions) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeLocalUploadOptions performs a merge with any union data inside the UploadOptions, using the provided LocalUploadOptions
func (t *UploadOptions) MergeLocalUploadOptions(v LocalUploadOptions) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsOCIUploadOptions returns the union data inside the UploadOptions as a OCIUploadOptions
func (t UploadOptions) AsOCIUploadOptions() (OCIUploadOptions, error) {
	var body OCIUploadOptions
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromOCIUploadOptions overwrites any union data inside the UploadOptions as the provided OCIUploadOptions
func (t *UploadOptions) FromOCIUploadOptions(v OCIUploadOptions) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeOCIUploadOptions performs a merge with any union data inside the UploadOptions, using the provided OCIUploadOptions
func (t *UploadOptions) MergeOCIUploadOptions(v OCIUploadOptions) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPulpOSTreeUploadOptions returns the union data inside the UploadOptions as a PulpOSTreeUploadOptions
func (t UploadOptions) AsPulpOSTreeUploadOptions() (PulpOSTreeUploadOptions, error) {
	var body PulpOSTreeUploadOptions
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPulpOSTreeUploadOptions overwrites any union data inside the UploadOptions as the provided PulpOSTreeUploadOptions
func (t *UploadOptions) FromPulpOSTreeUploadOptions(v PulpOSTreeUploadOptions) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePulpOSTreeUploadOptions performs a merge with any union data inside the UploadOptions, using the provided PulpOSTreeUploadOptions
func (t *UploadOptions) MergePulpOSTreeUploadOptions(v PulpOSTreeUploadOptions) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t UploadOptions) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *UploadOptions) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsAWSEC2UploadStatus returns the union data inside the UploadStatus_Options as a AWSEC2UploadStatus
func (t UploadStatus_Options) AsAWSEC2UploadStatus() (AWSEC2UploadStatus, error) {
	var body AWSEC2UploadStatus
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAWSEC2UploadStatus overwrites any union data inside the UploadStatus_Options as the provided AWSEC2UploadStatus
func (t *UploadStatus_Options) FromAWSEC2UploadStatus(v AWSEC2UploadStatus) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAWSEC2UploadStatus performs a merge with any union data inside the UploadStatus_Options, using the provided AWSEC2UploadStatus
func (t *UploadStatus_Options) MergeAWSEC2UploadStatus(v AWSEC2UploadStatus) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsAWSS3UploadStatus returns the union data inside the UploadStatus_Options as a AWSS3UploadStatus
func (t UploadStatus_Options) AsAWSS3UploadStatus() (AWSS3UploadStatus, error) {
	var body AWSS3UploadStatus
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAWSS3UploadStatus overwrites any union data inside the UploadStatus_Options as the provided AWSS3UploadStatus
func (t *UploadStatus_Options) FromAWSS3UploadStatus(v AWSS3UploadStatus) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAWSS3UploadStatus performs a merge with any union data inside the UploadStatus_Options, using the provided AWSS3UploadStatus
func (t *UploadStatus_Options) MergeAWSS3UploadStatus(v AWSS3UploadStatus) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsGCPUploadStatus returns the union data inside the UploadStatus_Options as a GCPUploadStatus
func (t UploadStatus_Options) AsGCPUploadStatus() (GCPUploadStatus, error) {
	var body GCPUploadStatus
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromGCPUploadStatus overwrites any union data inside the UploadStatus_Options as the provided GCPUploadStatus
func (t *UploadStatus_Options) FromGCPUploadStatus(v GCPUploadStatus) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeGCPUploadStatus performs a merge with any union data inside the UploadStatus_Options, using the provided GCPUploadStatus
func (t *UploadStatus_Options) MergeGCPUploadStatus(v GCPUploadStatus) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsAzureUploadStatus returns the union data inside the UploadStatus_Options as a AzureUploadStatus
func (t UploadStatus_Options) AsAzureUploadStatus() (AzureUploadStatus, error) {
	var body AzureUploadStatus
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAzureUploadStatus overwrites any union data inside the UploadStatus_Options as the provided AzureUploadStatus
func (t *UploadStatus_Options) FromAzureUploadStatus(v AzureUploadStatus) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAzureUploadStatus performs a merge with any union data inside the UploadStatus_Options, using the provided AzureUploadStatus
func (t *UploadStatus_Options) MergeAzureUploadStatus(v AzureUploadStatus) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsContainerUploadStatus returns the union data inside the UploadStatus_Options as a ContainerUploadStatus
func (t UploadStatus_Options) AsContainerUploadStatus() (ContainerUploadStatus, error) {
	var body ContainerUploadStatus
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromContainerUploadStatus overwrites any union data inside the UploadStatus_Options as the provided ContainerUploadStatus
func (t *UploadStatus_Options) FromContainerUploadStatus(v ContainerUploadStatus) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeContainerUploadStatus performs a merge with any union data inside the UploadStatus_Options, using the provided ContainerUploadStatus
func (t *UploadStatus_Options) MergeContainerUploadStatus(v ContainerUploadStatus) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsOCIUploadStatus returns the union data inside the UploadStatus_Options as a OCIUploadStatus
func (t UploadStatus_Options) AsOCIUploadStatus() (OCIUploadStatus, error) {
	var body OCIUploadStatus
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromOCIUploadStatus overwrites any union data inside the UploadStatus_Options as the provided OCIUploadStatus
func (t *UploadStatus_Options) FromOCIUploadStatus(v OCIUploadStatus) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeOCIUploadStatus performs a merge with any union data inside the UploadStatus_Options, using the provided OCIUploadStatus
func (t *UploadStatus_Options) MergeOCIUploadStatus(v OCIUploadStatus) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPulpOSTreeUploadStatus returns the union data inside the UploadStatus_Options as a PulpOSTreeUploadStatus
func (t UploadStatus_Options) AsPulpOSTreeUploadStatus() (PulpOSTreeUploadStatus, error) {
	var body PulpOSTreeUploadStatus
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPulpOSTreeUploadStatus overwrites any union data inside the UploadStatus_Options as the provided PulpOSTreeUploadStatus
func (t *UploadStatus_Options) FromPulpOSTreeUploadStatus(v PulpOSTreeUploadStatus) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePulpOSTreeUploadStatus performs a merge with any union data inside the UploadStatus_Options, using the provided PulpOSTreeUploadStatus
func (t *UploadStatus_Options) MergePulpOSTreeUploadStatus(v PulpOSTreeUploadStatus) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsLocalUploadStatus returns the union data inside the UploadStatus_Options as a LocalUploadStatus
func (t UploadStatus_Options) AsLocalUploadStatus() (LocalUploadStatus, error) {
	var body LocalUploadStatus
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromLocalUploadStatus overwrites any union data inside the UploadStatus_Options as the provided LocalUploadStatus
func (t *UploadStatus_Options) FromLocalUploadStatus(v LocalUploadStatus) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeLocalUploadStatus performs a merge with any union data inside the UploadStatus_Options, using the provided LocalUploadStatus
func (t *UploadStatus_Options) MergeLocalUploadStatus(v LocalUploadStatus) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t UploadStatus_Options) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *UploadStatus_Options) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// The status of a cloned compose
	// (GET /clones/{id})
	GetCloneStatus(ctx echo.Context, id openapi_types.UUID) error
	// Create compose
	// (POST /compose)
	PostCompose(ctx echo.Context) error
	// The list of composes
	// (GET /composes/)
	GetComposeList(ctx echo.Context) error
	// The status of a compose
	// (GET /composes/{id})
	GetComposeStatus(ctx echo.Context, id openapi_types.UUID) error
	// Clone an existing compose
	// (POST /composes/{id}/clone)
	PostCloneCompose(ctx echo.Context, id openapi_types.UUID) error
	// Download the artifact for a compose.
	// (GET /composes/{id}/download)
	GetComposeDownload(ctx echo.Context, id openapi_types.UUID) error
	// Get logs for a compose.
	// (GET /composes/{id}/logs)
	GetComposeLogs(ctx echo.Context, id openapi_types.UUID) error
	// Get the manifests for a compose.
	// (GET /composes/{id}/manifests)
	GetComposeManifests(ctx echo.Context, id openapi_types.UUID) error
	// Get the metadata for a compose.
	// (GET /composes/{id}/metadata)
	GetComposeMetadata(ctx echo.Context, id openapi_types.UUID) error
	// Get the SBOMs for a compose.
	// (GET /composes/{id}/sboms)
	GetComposeSBOMs(ctx echo.Context, id openapi_types.UUID) error
	// Depsolve one or more blueprints
	// (POST /depsolve/blueprint)
	PostDepsolveBlueprint(ctx echo.Context) error
	// Get all of the supported distribution repository details
	// (GET /distributions)
	GetDistributionList(ctx echo.Context) error
	// Get a list of all possible errors
	// (GET /errors)
	GetErrorList(ctx echo.Context, params GetErrorListParams) error
	// Get error description
	// (GET /errors/{id})
	GetError(ctx echo.Context, id string) error
	// Get the openapi spec in json format
	// (GET /openapi)
	GetOpenapi(ctx echo.Context) error
	// Search for detailed information on a list of package names
	// (POST /search/packages)
	PostSearchPackages(ctx echo.Context) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// GetCloneStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetCloneStatus(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(BearerScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetCloneStatus(ctx, id)
	return err
}

// PostCompose converts echo context to params.
func (w *ServerInterfaceWrapper) PostCompose(ctx echo.Context) error {
	var err error

	ctx.Set(BearerScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostCompose(ctx)
	return err
}

// GetComposeList converts echo context to params.
func (w *ServerInterfaceWrapper) GetComposeList(ctx echo.Context) error {
	var err error

	ctx.Set(BearerScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetComposeList(ctx)
	return err
}

// GetComposeStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetComposeStatus(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(BearerScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetComposeStatus(ctx, id)
	return err
}

// PostCloneCompose converts echo context to params.
func (w *ServerInterfaceWrapper) PostCloneCompose(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostCloneCompose(ctx, id)
	return err
}

// GetComposeDownload converts echo context to params.
func (w *ServerInterfaceWrapper) GetComposeDownload(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(BearerScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetComposeDownload(ctx, id)
	return err
}

// GetComposeLogs converts echo context to params.
func (w *ServerInterfaceWrapper) GetComposeLogs(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetComposeLogs(ctx, id)
	return err
}

// GetComposeManifests converts echo context to params.
func (w *ServerInterfaceWrapper) GetComposeManifests(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetComposeManifests(ctx, id)
	return err
}

// GetComposeMetadata converts echo context to params.
func (w *ServerInterfaceWrapper) GetComposeMetadata(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(BearerScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetComposeMetadata(ctx, id)
	return err
}

// GetComposeSBOMs converts echo context to params.
func (w *ServerInterfaceWrapper) GetComposeSBOMs(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetComposeSBOMs(ctx, id)
	return err
}

// PostDepsolveBlueprint converts echo context to params.
func (w *ServerInterfaceWrapper) PostDepsolveBlueprint(ctx echo.Context) error {
	var err error

	ctx.Set(BearerScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostDepsolveBlueprint(ctx)
	return err
}

// GetDistributionList converts echo context to params.
func (w *ServerInterfaceWrapper) GetDistributionList(ctx echo.Context) error {
	var err error

	ctx.Set(BearerScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetDistributionList(ctx)
	return err
}

// GetErrorList converts echo context to params.
func (w *ServerInterfaceWrapper) GetErrorList(ctx echo.Context) error {
	var err error

	ctx.Set(BearerScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetErrorListParams
	// ------------- Optional query parameter "page" -------------

	err = runtime.BindQueryParameter("form", true, false, "page", ctx.QueryParams(), &params.Page)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter page: %s", err))
	}

	// ------------- Optional query parameter "size" -------------

	err = runtime.BindQueryParameter("form", true, false, "size", ctx.QueryParams(), &params.Size)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter size: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetErrorList(ctx, params)
	return err
}

// GetError converts echo context to params.
func (w *ServerInterfaceWrapper) GetError(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(BearerScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetError(ctx, id)
	return err
}

// GetOpenapi converts echo context to params.
func (w *ServerInterfaceWrapper) GetOpenapi(ctx echo.Context) error {
	var err error

	ctx.Set(BearerScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetOpenapi(ctx)
	return err
}

// PostSearchPackages converts echo context to params.
func (w *ServerInterfaceWrapper) PostSearchPackages(ctx echo.Context) error {
	var err error

	ctx.Set(BearerScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostSearchPackages(ctx)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface) {
	RegisterHandlersWithBaseURL(router, si, "")
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET(baseURL+"/clones/:id", wrapper.GetCloneStatus)
	router.POST(baseURL+"/compose", wrapper.PostCompose)
	router.GET(baseURL+"/composes/", wrapper.GetComposeList)
	router.GET(baseURL+"/composes/:id", wrapper.GetComposeStatus)
	router.POST(baseURL+"/composes/:id/clone", wrapper.PostCloneCompose)
	router.GET(baseURL+"/composes/:id/download", wrapper.GetComposeDownload)
	router.GET(baseURL+"/composes/:id/logs", wrapper.GetComposeLogs)
	router.GET(baseURL+"/composes/:id/manifests", wrapper.GetComposeManifests)
	router.GET(baseURL+"/composes/:id/metadata", wrapper.GetComposeMetadata)
	router.GET(baseURL+"/composes/:id/sboms", wrapper.GetComposeSBOMs)
	router.POST(baseURL+"/depsolve/blueprint", wrapper.PostDepsolveBlueprint)
	router.GET(baseURL+"/distributions", wrapper.GetDistributionList)
	router.GET(baseURL+"/errors", wrapper.GetErrorList)
	router.GET(baseURL+"/errors/:id", wrapper.GetError)
	router.GET(baseURL+"/openapi", wrapper.GetOpenapi)
	router.POST(baseURL+"/search/packages", wrapper.PostSearchPackages)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
